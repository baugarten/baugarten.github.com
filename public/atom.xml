<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Codenfreude]]></title>
  <link href="http://baugarten.github.com/atom.xml" rel="self"/>
  <link href="http://baugarten.github.com/"/>
  <updated>2012-07-31T22:22:29-07:00</updated>
  <id>http://baugarten.github.com/</id>
  <author>
    <name><![CDATA[Ben Augarten]]></name>
    <email><![CDATA[baugarten@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[the cost of learning]]></title>
    <link href="http://baugarten.github.com/blog/2012/07/31/the-cost-of-learning/"/>
    <updated>2012-07-31T21:42:00-07:00</updated>
    <id>http://baugarten.github.com/blog/2012/07/31/the-cost-of-learning</id>
    <content type="html"><![CDATA[<p>It is hard to say when a problem warrants the extra effort of learning a new technology or framework or library. While learning a new technology can dramatically increase productivity, a shotgun approach with no direction can lead to a false sense of accomplishment and stall real progress. At the same time, accepting broken and old technologies can lead to reinventing the wheel or horribly unmaintainable code.</p>

<p>There exists a spectrum in programmers, the extremes being those that learn all the new technology and those that only master a few technologies, ignoring new ones, on which every one of us falls. Either one becomes stuck using outdated tools (I’m a QBASIC pro!) or constantly keeping up with the edge of new technology, all too eager to fall forward into the abyss. Of course there exists a happy medium somewhere along the spectrum, which is sometimes unclear.</p>

<p>When developing a project in a timely manner, I would like to propose that the happy medium is learning on demand. Sure, reading hacker news articles is fine in your free time, but an in depth evaluation of new technologies should be learned on demand in the context of a real project &#8211; not in a contrived instance, but when a project you work on necessitates the use of a tool you’ve heard about, then learn it. At the same time, don’t be afraid of learning it because it will ideally make your code simpler, more maintainable and DRYer. Plus, if you don’t learn and use it, you’ll regret it and have to rewrite it soon enough.</p>

<p>Identify the signs that you need to learn something new. If you have code smells, you don’t know where to place certain lines of code, or have tightly coupled, untestable modules, then yeah you need to simplify your code, learn a framework, abstract out a library, take the time to pay off your technical debt.</p>

<p>Paying off technical debt isn’t as easy as it seems. I’m a hedonist when I program &#8211; I love writing code and seeing changes. This is my biggest problem &#8211; the immediate gratification of ignoring new technology. I accumulate technical debt to achieve tangible results (new UI, functionality, etc) faster, but in the long run my code turns to complete manure.</p>

<p>I’ve been working on a client-intensive web app. Started off without a javascript framework &#8211; big mistake. My client side code turned into a complete mess &#8211; I tried to separate it into a loose MVC, but it was too tightly coupled, completely untestable, and everything was hard to track down. I kept developing like nothing was wrong, watching the UI change. Please, don’t be like me. I knew I was wrong, there are tons of javascript frameworks that make code organization and modularity easy, I was just stubborn in my own ways, enjoying rolling my own until I finally got the point where a major refactor was inevitable.</p>

<p>Enter requirejs and Backbone. I had to rewrite everything I did &#8211; it took me all summer to rewrite, but I finally learned that I need not hesitate to learn something new. After all, that’s why I’m writing the app. The point is, my stubborness slowed me down tremendously, don’t be stubborn.</p>

<p>It also goes the other way: if you’re one of those people that rattles off all the latest libraries and frameworks and knows too many languages and has too little time in each one, then maybe settle down and start a project. It’s a fine balance, but when your code starts to smell, learn how to fix it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[learn to love frustration]]></title>
    <link href="http://baugarten.github.com/blog/2012/07/08/learn-to-love-frustration/"/>
    <updated>2012-07-08T20:28:00-07:00</updated>
    <id>http://baugarten.github.com/blog/2012/07/08/learn-to-love-frustration</id>
    <content type="html"><![CDATA[<p>programming is frustrating. If you disagree, <a href="mailto:baugarten@gmail.com">email me</a>. It should be frustrating, it means it&#8217;s challenging &#8211; frustration oriented programming transcends language and time. It should be taught and encouraged.</p>

<p>Just the other day I copied a dependency to a new location, changed all the files linking to it, but then edited the old file, confused why the changes weren&#8217;t being applied, finally realizing my error after thirty painful minutes (I was learning a new configuration language in my defense). Of course, I felt like an idiot, but I already knew I was an idiot so I just kept going. That&#8217;s the thing, I don&#8217;t get frustrated by programming, I almost seek the inevitable frustration of learning new languages and libraries and practices &#8211; I learned how to program during high school by myself on a caffeine binge at 4 in the morning on a school night debugging segmentation faults (I realize I sound really cool right now). It was painful. But I learned valuable lessons &#8211; check the most obvious problems first, compartmentalize potential failures, and eventually just use the debugger, it is there for a reason. I&#8217;m glad I did it though, because, sure, I didn&#8217;t know any better and was just messing around, but now it takes a lot to frustrate me, I dare you to try. I own undocumented APIs, null pointers and all things horrible because I&#8217;ve chased much dumber problems and wasted my time doing stupider things.</p>

<p>It&#8217;s frustration that makes programming a mystic and almost legendary profession. People wonder how programmers began, as if they woke up one morning and wrote the linux kernel, how I imagine others find their professions. Most other people will immediately throw their hands in the air and ask for help when encountering an unfamiliar problem (think parents and computers), but the programmer doesn&#8217;t &#8211; they have an uncanny ability to stare frustration down the throat and continue on. That&#8217;s how I started programming; debugging my computer problems turned into linux turned into bash turned into C. I was not magic. I just put in a lot of work and learned a lot &#8211; a lot about how I deal with frustration. I&#8217;m lucky, I deal marvelously with frustration &#8211; programmers need to.</p>

<p>This ability should be taught not just as a byproduct of computer science &#8211; frustration lies at the heart of all programming and in this imperfect science I believe it always will. No code is perfect, everything is broken, and it all fails spectacularly in the most surprising of ways. Students need to be taught how to cope with, seek, and love frustration, immunize themselves to it or else they will never be able to sustain a lifetime of learning as a programmer. If ever someone stops becoming frustrated, they probably aren&#8217;t challenging themselves, learning anything new, and they most definitely aren&#8217;t advancing computer science.</p>

<p>Ways to deal with frustration should be taught in schools. Not everything is magic, sometimes failure is necessary, especially in programming. But it&#8217;s not just in programming &#8211; I surmise that frustration is one of the root problems of America&#8217;s lack of budding scientists (but this calls for another post and actual research). No one wants to learn science because science has clear cut failure that frustrates students who aren&#8217;t used to coping. The failure and frustration in the sciences makes it hard and unapproachable. Students should be taught to deal with frustration productively, challenged to fail early on, and I hope it won&#8217;t be alone at 4 in the morning with a cup of coffee. Frustration is everywhere, learn to love it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[default behavior]]></title>
    <link href="http://baugarten.github.com/blog/2012/07/02/default-behavior/"/>
    <updated>2012-07-02T20:25:00-07:00</updated>
    <id>http://baugarten.github.com/blog/2012/07/02/default-behavior</id>
    <content type="html"><![CDATA[<p>Everyone should publish something they wrote on their own &#8211; their own conception, implementation, and product. It is a completely unique, surreal feeling sending your own brainchild out into the world, seeing people use it and finally tear it to shreds. I recently began an internship (and soon will finish), tirelessly writing code that I&#8217;ll never see again, as a developer or user. I am writing an internal tool, possibly the worst combination of words an undermotivated 19 year old intern could hear. I lazily submit chunks of code, waving goodbye as they disappear into the abyss of &#8216;production.&#8217; I&#8217;ll never look at them again, and I&#8217;m sure no one else will either. Whatever I wrote will forever live in a zombie state, it will never die, on the off chance it bites back, but it will never really live and serve its purpose either (I&#8217;ll leave before its done), much like developers that sell out too early. I understand the need for money, but why settle for a full time, 9-5/6/7/8? job when programmers have a unique opportunity to create nearly anything they want with they own computer? Not many professions have the opportunity to take their craft into their home and make something useful for people everywhere.</p>

<p>I talk mostly to college students and recent grads, but I find that people don&#8217;t often evaluate their work experience and excuse their own lack of independence by citing perks and (sometimes falsly construed) perceptions of monetary necessity. Sure, I get it, there are top chefs and free food and espresso machines and rock walls and there&#8217;s someone that wipes them after they go to the bathroom, but at the end of the day, I&#8217;m sure they are just as unsatisfied as I am, wishing they had the energy to work on something they really care about. I hear about people&#8217;s &#8216;side projects&#8217; all the time but what stops their side projects from taking over their lives? I know I can&#8217;t help but let my side projects take over my life. I try to see past the perks, but the walls of my cubicle sometimes block my view.</p>

<p>It seems easy to fall into the trap, especially for a college grad used to cheap vodka and ramen, but nothing stacks up to the amazing feeling of making something that you care about. It doesn&#8217;t even have to be good. People don&#8217;t even have to like it. Hell, people don&#8217;t even have to use it! Don&#8217;t believe me? I recently developed a pretty terrible <a href="https://play.google.com/store/apps/details?id=com.owleyes.moustache&amp;hl=en">android app</a>, its buggy on certain systems (it works on mine, I swear), but I love it! I loved making it and I especially love watching the number of people using it slowly climb to my delight and scouring at the terrible reviews (I&#8217;m on an old api, leave me alone). It is my own. And I swear that I will not settle into a cubicle (again) until I chase down that thrill of self fulfillment, chain myself to it, and, in case of emergency, fail miraculously, believing in what I did &#8211; this should be the default behavior.</p>
]]></content>
  </entry>
  
</feed>
